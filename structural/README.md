# 结构型(Structural)

结构型模式**描述如何将类或对象按某种布局组成更大的结构**。它分为**类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象**。

**由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性**。

结构型模式分为以下 7 种：

1. [**代理（Proxy）模式**](proxy.md)：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。*当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。*
2. [**适配器（Adapter）模式**](adapter.md)：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。*需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。*
3. [**桥接（Bridge）模式**](bridge.md)：将抽象与实现分离，使它们可以独立变化。*它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。*
4. [**装饰（Decorator）模式**](decorator.md)：动态地给对象增加一些职责，即增加其额外的功能。*使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。*
5. [**外观（Facade）模式**](facade.md)：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。*对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性*。*主要定义了一个高层接口，它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能*。
6. [**享元（Flyweight）模式**](flyweight.md)：运用共享技术来有效地支持大量细粒度对象的复用。*通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率*。
7. [**组合（Composite）模式**](composite.md)：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。*组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”。*


以上 7 种结构型模式，除了[适配器模式](adapter.md)分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式，下面我们会分别、详细地介绍它们的特点、结构与应用。
