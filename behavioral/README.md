# 行为型(Behavioral)

行为型模式**用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配**。

**行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为**。**由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性**。

行为型模式是 GoF [设计模式](http://c.biancheng.net/design_pattern/)中最为庞大的一类，它包含以下 11 种模式。

1. **[模板方法（Template Method）模式]()**：**定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤**。*它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。*
2. **[策略（Strategy）模式]()**：**定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户**。*通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理*。
3. **[命令（Command）模式](command.md)**：**将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开**。*这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。*
4. **[职责链（Chain of Responsibility）模式](chain_of_responsibility.md)**：**把请求从链中的一个对象传到下一个对象，直到请求被响应为止**。*在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。*
5. **[状态（State）模式](state.md)**：**允许一个对象在其内部状态发生改变时改变其行为能力**。**状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变**。*当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，放到一系列的状态类当中，这样可以把原来复杂的逻辑判断简单化。*
6. **[观察者（Observer）模式](observer.md)**：**多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为**。*这种模式有时又称作发布-订阅模式、模型-视图模式。*
7. **[中介者（Mediator）模式](mediator.md)**：**定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解**。*中介者模式又叫调停模式，它是迪米特法则的典型应用*。
8. **[迭代器（Iterator）模式](iterator.md)**：**提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示**。*迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据*。
9. **[访问者（Visitor）模式](visitor.md)**：**在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问**。*被处理的数据元素相对稳定，而访问方式多种多样。把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性*。
10. **[备忘录（Memento）模式](memento.md)**：**在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它**。备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。该模式又叫**快照模式**。
11. **[解释器（Interpreter）模式](interpreter.md)**：**提供如何定义语言的文法，以及对语言句子的解释方法，即解释器**。*“文法”指语言的语法规则，而“句子”是语言集中的元素*。*解释器模式常用于对简单语言的编译或分析实例中。*


以上 11 种行为型模式，除了模板方法模式和[解释器模式](http://c.biancheng.net/view/1402.html)是类行为型模式，其他的全部属于对象行为型模式，下面我们将详细介绍它们的特点、结构与应用。
